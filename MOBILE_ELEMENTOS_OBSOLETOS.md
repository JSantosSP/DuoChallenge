# üîç Elementos Obsoletos o a Revisar - Mobile DuoChallenge

**Fecha de an√°lisis:** 2025-10-26

## üìå Resumen

Tras el an√°lisis exhaustivo del c√≥digo mobile, se han identificado algunos elementos que podr√≠an requerir revisi√≥n, limpieza o mejora. Este documento no indica necesariamente que deban eliminarse, sino que merecen atenci√≥n para optimizar el c√≥digo.

---

## ‚ö†Ô∏è Elementos a Revisar

### 1. Estados de Loading Duplicados

**Ubicaci√≥n:** M√∫ltiples pantallas (HomeScreen, GameDetailScreen, etc.)

**Problema:**
- Muchas pantallas implementan su propio estado `loading` y `refreshing`
- Esto genera c√≥digo duplicado y podr√≠a abstraerse

**Sugerencia:**
```javascript
// Crear un hook personalizado
function useRefreshableQuery(queryKey, queryFn) {
  const [refreshing, setRefreshing] = useState(false);
  const { data, isLoading, refetch } = useQuery({ queryKey, queryFn });
  
  const onRefresh = async () => {
    setRefreshing(true);
    await refetch();
    setRefreshing(false);
  };
  
  return { data, isLoading, refreshing, onRefresh, refetch };
}
```

---

### 2. Validaciones de Formulario Repetidas

**Ubicaci√≥n:** `AddEditDataScreen.js`, `EditPrizeScreen.js`

**Problema:**
- L√≥gica de validaci√≥n similar en m√∫ltiples pantallas
- Podr√≠an extraerse a funciones reutilizables o un hook

**Ejemplo actual:**
```javascript
// En AddEditDataScreen
const validateForm = () => {
  if (!formData.tipoDato) {
    Alert.alert('Error', 'Selecciona un tipo de dato');
    return false;
  }
  // ... m√°s validaciones
}

// En EditPrizeScreen (similar)
const validateForm = () => {
  if (!formData.title.trim()) {
    Alert.alert('Error', 'El t√≠tulo es requerido');
    return false;
  }
  // ... m√°s validaciones
}
```

**Sugerencia:**
```javascript
// utils/validation.js
export const validateRequired = (value, fieldName) => {
  if (!value?.trim()) {
    Alert.alert('Error', `${fieldName} es requerido`);
    return false;
  }
  return true;
};
```

---

### 3. Estilos Duplicados entre Screens

**Ubicaci√≥n:** Todas las pantallas

**Problema:**
- Muchos estilos comunes se repiten en m√∫ltiples archivos
- Especialmente: `container`, `scroll`, `header`, `title`, `subtitle`, `section`

**Ejemplo:**
```javascript
// Repetido en casi todas las screens
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.neutral.backgroundLight,
  },
  scroll: {
    flex: 1,
  },
  // ... etc
});
```

**Sugerencia:**
- Crear `src/styles/commonStyles.js` con estilos compartidos
- Importar y extender cuando sea necesario

```javascript
// styles/commonStyles.js
export const commonStyles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.neutral.backgroundLight,
  },
  scroll: {
    flex: 1,
  },
  // ... etc
});

// En las screens
import { commonStyles } from '../styles/commonStyles';
const styles = StyleSheet.create({
  ...commonStyles,
  // estilos espec√≠ficos de la screen
});
```

---

### 4. Funci√≥n getImageUrl Duplicada

**Ubicaci√≥n:** `/config/env.js` y `/api/api.js`

**Problema:**
- `getImageUrl` se define en `env.js`
- Se re-exporta en `api.js`
- Podr√≠a simplificarse

**Actual:**
```javascript
// env.js
export const getImageUrl = (imagePath) => { ... }

// api.js
export { getImageUrl } from '../config/env';
```

**Sugerencia:**
- Mantener solo en `env.js` y importar directamente donde se necesite
- O mantener re-export pero documentar claramente por qu√©

---

### 5. Manejo de Errores Inconsistente

**Ubicaci√≥n:** Hooks personalizados (`usePrize`, `useShare`, `useUserData`)

**Problema:**
- Algunos usan `try/catch` con `Alert.alert`
- Otros propagan errores
- No hay un patr√≥n consistente

**Ejemplo:**
```javascript
// usePrize.js - muestra alert
const createPrize = async (data) => {
  try {
    // ...
  } catch (error) {
    Alert.alert('Error', 'Error al crear premio');
    return { success: false, message };
  }
};

// useGame.js - usa callbacks de React Query
const verifyMutation = useMutation({
  mutationFn: ({ levelId, payload }) => apiService.verifyLevel(levelId, payload),
  onSuccess: (data) => { /* ... */ },
  onError: (error) => { /* ... */ },
});
```

**Sugerencia:**
- Estandarizar: preferir usar callbacks de React Query (onSuccess/onError)
- O crear un hook `useErrorHandler` centralizado

---

### 6. Refresh Token no Implementado

**Ubicaci√≥n:** `AuthContext.js`

**Problema:**
- Existe funci√≥n `refreshAuthToken()` pero no se usa autom√°ticamente
- Cuando el token expira, se hace logout directo
- No se intenta refrescar antes de cerrar sesi√≥n

**Sugerencia:**
```javascript
// En el interceptor de respuesta de axios
api.interceptors.response.use(
  (response) => response,
  async (error) => {
    if (error.response?.status === 401) {
      // Intentar refresh antes de logout
      const refreshed = await refreshAuthToken();
      if (refreshed.success) {
        // Reintentar petici√≥n original
        return api.request(error.config);
      }
      // Si falla el refresh, entonces hacer logout
      await logout();
    }
    return Promise.reject(error);
  }
);
```

---

### 7. C√≥digos de Estado Hardcodeados

**Ubicaci√≥n:** M√∫ltiples archivos

**Problema:**
- Estados y mensajes est√°n hardcodeados en el c√≥digo
- Dificulta i18n futura y mantenimiento

**Ejemplo:**
```javascript
// En GameHistoryScreen
const getStatusLabel = (status) => {
  switch (status) {
    case 'completed': return '‚úì Completado';
    case 'active': return '‚è≥ Activo';
    case 'abandoned': return '‚úï Abandonado';
    default: return status;
  }
};
```

**Sugerencia:**
```javascript
// constants/gameStatus.js
export const GAME_STATUS = {
  COMPLETED: 'completed',
  ACTIVE: 'active',
  ABANDONED: 'abandoned',
};

export const GAME_STATUS_LABELS = {
  [GAME_STATUS.COMPLETED]: '‚úì Completado',
  [GAME_STATUS.ACTIVE]: '‚è≥ Activo',
  [GAME_STATUS.ABANDONED]: '‚úï Abandonado',
};
```

---

### 8. Console.logs en Producci√≥n

**Ubicaci√≥n:** `PrizeScreen.js`, otros archivos

**Problema:**
- Existen `console.log` y `console.error` en el c√≥digo
- Deber√≠an removerse o condicionarse para producci√≥n

**Ejemplo:**
```javascript
// PrizeScreen.js
useEffect(() => {
  console.log('PrizeScreen - Received params:', { gameSetId, shareCode });
}, [gameSetId, shareCode]);
```

**Sugerencia:**
```javascript
// utils/logger.js
export const logger = {
  log: (...args) => {
    if (__DEV__) console.log(...args);
  },
  error: (...args) => {
    if (__DEV__) console.error(...args);
  },
  warn: (...args) => {
    if (__DEV__) console.warn(...args);
  },
};

// Uso
import { logger } from '../utils/logger';
logger.log('Debug info:', data);
```

---

### 9. Magic Numbers en Estilos

**Ubicaci√≥n:** Todos los archivos de estilos

**Problema:**
- Valores num√©ricos repetidos sin nombrar (padding: 24, borderRadius: 16, etc.)
- Dificulta mantener consistencia visual

**Ejemplo:**
```javascript
const styles = StyleSheet.create({
  card: {
    padding: 24,
    borderRadius: 16,
    // ...
  },
  button: {
    padding: 16,
    borderRadius: 12,
    // ...
  },
});
```

**Sugerencia:**
```javascript
// constants/spacing.js
export const spacing = {
  xs: 4,
  sm: 8,
  md: 12,
  lg: 16,
  xl: 24,
  xxl: 32,
};

export const borderRadius = {
  sm: 8,
  md: 12,
  lg: 16,
  xl: 24,
};

// Uso
import { spacing, borderRadius } from '../constants/spacing';
const styles = StyleSheet.create({
  card: {
    padding: spacing.xl,
    borderRadius: borderRadius.lg,
  },
});
```

---

### 10. Falta de Manejo de Errores de Red

**Ubicaci√≥n:** Hooks y componentes que usan API

**Problema:**
- No hay manejo expl√≠cito para errores de red (sin internet, timeout)
- Usuario no recibe feedback claro en estos casos

**Sugerencia:**
```javascript
// En los hooks
const { data, error, isLoading } = useQuery({
  queryKey: ['data'],
  queryFn: fetchData,
  retry: (failureCount, error) => {
    // No reintentar en errores de red
    if (error.message === 'Network Error') return false;
    return failureCount < 3;
  },
});

// Mostrar mensaje espec√≠fico
if (error?.message === 'Network Error') {
  return <NetworkErrorComponent onRetry={refetch} />;
}
```

---

### 11. Navegaci√≥n con Par√°metros Impl√≠citos

**Ubicaci√≥n:** M√∫ltiples screens

**Problema:**
- Algunas pantallas asumen que ciertos par√°metros existen sin validar
- Puede causar crashes si se navega incorrectamente

**Ejemplo:**
```javascript
// LevelScreen.js
const { level } = route.params; // ¬øQu√© pasa si params es undefined?
```

**Sugerencia:**
```javascript
const { level } = route.params || {};
if (!level) {
  return <ErrorScreen message="Nivel no encontrado" />;
}
```

---

### 12. Falta de Paginaci√≥n en Listas

**Ubicaci√≥n:** `GameHistoryScreen`, `WonPrizesScreen`, otras

**Problema:**
- Se cargan todos los datos de una vez
- Puede ser lento con muchos registros

**Sugerencia:**
- Implementar paginaci√≥n o infinite scroll con React Query
```javascript
const { 
  data,
  fetchNextPage,
  hasNextPage,
} = useInfiniteQuery({
  queryKey: ['games'],
  queryFn: ({ pageParam = 0 }) => fetchGames(pageParam),
  getNextPageParam: (lastPage) => lastPage.nextCursor,
});
```

---

## ‚úÖ Elementos que NO son Problemas

### 1. Uso de `any` o tipos din√°micos
- **No aplica:** El proyecto usa JavaScript, no TypeScript
- Si se migra a TypeScript en el futuro, se deber√° tipar

### 2. Componentes grandes
- **An√°lisis:** Algunos componentes como `HomeScreen` son extensos pero bien organizados
- **Conclusi√≥n:** Es aceptable dado el contexto y funcionalidad

### 3. Uso de `useEffect` m√∫ltiples
- **An√°lisis:** Cada `useEffect` tiene una responsabilidad espec√≠fica
- **Conclusi√≥n:** Uso correcto de hooks

---

## üìä Priorizaci√≥n de Mejoras

### Alta Prioridad üî¥
1. Refresh token autom√°tico (seguridad)
2. Manejo de errores de red (UX)
3. Console.logs en producci√≥n (performance/seguridad)
4. Validaci√≥n de par√°metros de navegaci√≥n (estabilidad)

### Media Prioridad üü°
1. Estilos duplicados
2. Validaciones duplicadas
3. Estados de loading duplicados
4. C√≥digos de estado hardcodeados

### Baja Prioridad üü¢
1. Magic numbers en estilos
2. Paginaci√≥n en listas
3. getImageUrl duplicada

---

## üîÑ Plan de Acci√≥n Sugerido

1. **Fase 1 - Estabilidad (Prioridad Alta)**
   - Implementar refresh token autom√°tico
   - Agregar manejo de errores de red
   - Crear wrapper para console.log
   - Validar par√°metros en navegaci√≥n

2. **Fase 2 - Refactorizaci√≥n (Prioridad Media)**
   - Crear commonStyles
   - Extraer validaciones a utilidades
   - Crear hook useRefreshableQuery
   - Centralizar constantes de estado

3. **Fase 3 - Optimizaci√≥n (Prioridad Baja)**
   - Definir spacing y borderRadius constants
   - Implementar paginaci√≥n donde necesario
   - Limpiar re-exports innecesarios

---

## üìù Notas Finales

- **Ninguno de estos elementos es cr√≠tico:** La aplicaci√≥n funciona correctamente
- **Son oportunidades de mejora:** Para mejor mantenibilidad y escalabilidad
- **Priorizar seg√∫n recursos:** No es necesario implementar todo de inmediato
- **Documentaci√≥n actualizada:** Este documento debe actualizarse al implementar cambios

---

**√öltima actualizaci√≥n:** 2025-10-26
**Autor del an√°lisis:** Documentaci√≥n autom√°tica del sistema